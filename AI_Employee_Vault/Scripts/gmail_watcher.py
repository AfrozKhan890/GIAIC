"""
Gmail Watcher for AI Employee
Checks for unread important emails and creates .md files in Needs_Action folder
"""

import os
import pickle
import base64
from datetime import datetime
from pathlib import Path
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# Gmail API scopes - hum sirf read kar rahe hain
SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']

class GmailWatcher:
    def __init__(self, vault_path):
        """Initialize watcher with path to Obsidian vault"""
        self.vault_path = Path(vault_path)
        self.needs_action = self.vault_path / 'Needs_Action'
        self.logs_path = self.vault_path / 'Logs'
        self.processed_ids = set()
        
        # Log file initialize karo
        self.log_file = self.logs_path / f'gmail_watcher_{datetime.now().strftime("%Y%m%d")}.log'
        
    def log(self, message, level="INFO"):
        """Log messages to file"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}\n"
        
        print(log_entry.strip())  # Console pe bhi dikhao
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    
    def get_gmail_service(self):
        """Authenticate and return Gmail service object"""
        creds = None
        token_path = Path(__file__).parent / 'token.pickle'
        
        # Token file load karo agar pehle se hai
        if token_path.exists():
            with open(token_path, 'rb') as token:
                creds = pickle.load(token)
        
        # Agar credentials valid nahi hain to naye lo
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    Path(__file__).parent / 'credentials.json', SCOPES)
                creds = flow.run_local_server(port=0)
            
            # Token save karo for next time
            with open(token_path, 'wb') as token:
                pickle.dump(creds, token)
        
        return build('gmail', 'v1', credentials=creds)
    
    def get_email_content(self, service, msg_id):
        """Get full email content by ID"""
        try:
            message = service.users().messages().get(
                userId='me', 
                id=msg_id,
                format='metadata',
                metadataHeaders=['From', 'Subject', 'Date']
            ).execute()
            
            # Headers extract karo
            headers = {}
            for header in message['payload']['headers']:
                headers[header['name']] = header['value']
            
            return {
                'id': msg_id,
                'from': headers.get('From', 'Unknown'),
                'subject': headers.get('Subject', 'No Subject'),
                'date': headers.get('Date', datetime.now().isoformat()),
                'snippet': message.get('snippet', '')
            }
        except HttpError as error:
            self.log(f"Error fetching email {msg_id}: {error}", "ERROR")
            return None
    
    def create_action_file(self, email_data):
        """Create .md file in Needs_Action folder"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"EMAIL_{timestamp}_{email_data['id'][:10]}.md"
        filepath = self.needs_action / filename
        
        content = f"""---
type: email
from: {email_data['from']}
subject: {email_data['subject']}
received: {email_data['date']}
processed: {datetime.now().isoformat()}
priority: high
status: pending
---

## ðŸ“§ Email Summary
**From:** {email_data['from']}
**Subject:** {email_data['subject']}
**Date:** {email_data['date']}

### Preview
{email_data['snippet']}

---

## âœ… Suggested Actions
- [ ] Read full email
- [ ] Reply to sender
- [ ] Forward if needed
- [ ] Archive after processing

## ðŸ“Œ Notes
_Add your notes here_

---
*Generated by AI Employee Gmail Watcher*
"""
        filepath.write_text(content, encoding='utf-8')
        self.log(f"Created action file: {filename}")
        return filepath
    
    def check_emails(self):
        """Check for new unread important emails"""
        try:
            service = self.get_gmail_service()
            
            # Query: unread AND important emails
            results = service.users().messages().list(
                userId='me',
                q='is:unread is:important',
                maxResults=10  # Ek baar mein max 10 emails
            ).execute()
            
            messages = results.get('messages', [])
            
            if not messages:
                self.log("No new important emails")
                return []
            
            self.log(f"Found {len(messages)} new important email(s)")
            
            new_files = []
            for message in messages:
                # Check if already processed (simple memory mein track karo)
                if message['id'] in self.processed_ids:
                    continue
                
                email_data = self.get_email_content(service, message['id'])
                if email_data:
                    filepath = self.create_action_file(email_data)
                    new_files.append(filepath)
                    self.processed_ids.add(message['id'])
            
            return new_files
            
        except HttpError as error:
            self.log(f"Gmail API error: {error}", "ERROR")
            return []
        except Exception as error:
            self.log(f"Unexpected error: {error}", "ERROR")
            return []
    
    def run_once(self):
        """Run a single check"""
        self.log("Starting Gmail check...")
        files = self.check_emails()
        self.log(f"Check complete. Created {len(files)} new files.")
        return files
    
    def run_continuous(self, interval_seconds=60):
        """Run continuously with specified interval"""
        self.log(f"Starting continuous monitoring (interval: {interval_seconds}s)")
        try:
            while True:
                self.run_once()
                import time
                time.sleep(interval_seconds)
        except KeyboardInterrupt:
            self.log("Stopped by user")

def main():
    """Main function to run the watcher"""
    # Vault path - ye change karo apne actual path ke according
    # vault_path = r"C:\Users\afroz\Desktop\GIAIC\AI_Employee_Vault"
    vault_path = r"C:\Users\afroz\Desktop\GIAIC\AI_Employee_Vault"
    
    # Create watcher instance
    watcher = GmailWatcher(vault_path)
    
    # Ek baar check karo
    watcher.run_once()
    
    # Agar continuous chahie to ye use karo:
    # watcher.run_continuous(interval_seconds=120)

if __name__ == "__main__":
    main()